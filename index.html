<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bored</title>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a1628;
            --bg-secondary: #1e3a8a;
            --surface-primary: #1e40af;
            --surface-secondary: #3b82f6;
            --text-primary: #ffffff;
            --text-secondary: #e2e8f0;
            --border: #3b82f6;
            --shadow: rgba(59, 130, 246, 0.3);
            --overlay: rgba(0, 0, 0, 0.7);
            --accent: #60a5fa;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            font-family: 'Comic Neue', cursive;
            user-select: none;
            gap: 2rem;
        }

        * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #display {
            font-size: 2.5rem;
            font-weight: bold;
            padding: 2rem;
            border-radius: 2rem;
            background: linear-gradient(145deg, var(--surface-primary), var(--surface-secondary));
            box-shadow: 0 20px 40px var(--shadow);
            cursor: pointer;
            color: var(--text-primary);
            text-align: center;
            width: calc(100vw - 4rem);
            max-width: 800px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            word-wrap: break-word;
            transition: all 0.3s ease;
            border: 2px solid var(--border);
            position: relative;
            gap: 1rem;
            margin: 2rem;
        }

        .card-text {
            font-size: 2.5rem;
            line-height: 1.2;
            margin-bottom: 0.5rem;
        }

        .card-button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 1rem;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-primary);
            background: linear-gradient(145deg, var(--accent), var(--surface-secondary));
            border: 2px solid var(--accent);
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            min-width: 120px;
        }

        .card-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px var(--shadow);
            background: linear-gradient(145deg, var(--surface-secondary), var(--accent));
        }

        .card-button:active {
            transform: translateY(0);
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay);
            z-index: 1000;
        }

        .popup-window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, var(--surface-primary), var(--surface-secondary));
            border-radius: 2rem;
            box-shadow: 0 20px 40px var(--shadow);
            border: 2px solid var(--border);
            padding: 2rem;
            width: 90%;
            max-width: 400px;
            font-family: 'Comic Neue', cursive;
            color: var(--text-primary);
        }

        .popup-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            text-align: center;
            color: var(--text-primary);
        }

        .setting-row {
            display: flex;
            flex-direction: column;
            margin-top: 1.5rem;
            gap: 0.5rem;
        }

        .setting-label {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--text-secondary);
            text-align: center;
        }

        .setting-input {
            padding: 1rem;
            border: 2px solid var(--border);
            border-radius: 1rem;
            font-family: inherit;
            font-size: 1rem;
            background: var(--surface-primary);
            color: var(--text-primary);
            text-align: center;
            transition: all 0.3s ease;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--shadow);
        }

        .popup-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .popup-button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 1rem;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-primary);
            background: linear-gradient(145deg, var(--surface-secondary), var(--accent));
            border: 2px solid var(--border);
            transition: all 0.3s ease;
        }

        .popup-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px var(--shadow);
        }

        .popup-button:active {
            transform: translateY(0);
        }

        /* Menu Icon Styles */
        .menu-icon {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, var(--surface-primary), var(--surface-secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 10px 20px var(--shadow);
            border: 2px solid var(--border);
            transition: all 0.3s ease;
            z-index: 999;
        }

        .menu-icon:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 30px var(--shadow);
        }

        .menu-icon svg {
            width: 24px;
            height: 24px;
            fill: var(--text-primary);
        }        /* Expanded Settings Styles */
        .settings-content {
            max-height: 80vh;
            overflow-y: auto;
            padding-right: 1rem;
            position: relative;
        }/* Custom scrollbar styling */
        .settings-content::-webkit-scrollbar {
            width: 12px;
        }

        .settings-content::-webkit-scrollbar-track {
            background: var(--surface-primary);
            border-radius: 6px;
        }

        .settings-content::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 6px;
        }

        .settings-content::-webkit-scrollbar-thumb:hover {
            background: var(--surface-secondary);
        }

        .data-section {
            margin-top: 2rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: var(--text-primary);
            text-align: center;
        }        .data-item {
            background: var(--surface-primary);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 1rem;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            position: relative;
            transition: all 0.3s ease;
        }        .data-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .data-item.drag-over {
            border-color: var(--accent);
            background: rgba(96, 165, 250, 0.1);
        }        /* Delete zone hint at bottom of screen */
        .drag-delete-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 38, 38, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1002;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .drag-delete-hint.show {
            opacity: 1;
        }

        .drag-handle {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 24px;
            height: 24px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            opacity: 0.6;
            transition: all 0.3s ease;
        }

        .drag-handle:hover {
            opacity: 1;
            color: var(--accent);
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .data-item-text {
            color: var(--text-primary);
            font-weight: bold;
            word-break: break-word;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }

        .data-item-text:hover {
            background: rgba(96, 165, 250, 0.1);
        }

        .data-item-text-input {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid var(--accent);
            border-radius: 0.5rem;
            background: var(--surface-secondary);
            color: var(--text-primary);
            font-family: inherit;
            font-weight: bold;
            font-size: inherit;
            outline: none;
            box-sizing: border-box;
        }

        .data-item-url {
            color: var(--text-secondary);
            font-size: 0.9rem;
            cursor: pointer;
            padding: 0.3rem 0.5rem;
            border-radius: 0.3rem;
            transition: all 0.3s ease;
        }

        .data-item-url:hover {
            background: rgba(96, 165, 250, 0.1);
        }

        .data-item-url-input {
            width: 100%;
            padding: 0.3rem 0.5rem;
            border: 2px solid var(--accent);
            border-radius: 0.3rem;
            background: var(--surface-secondary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            outline: none;
            box-sizing: border-box;
        }

        .weight-control {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .weight-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            min-width: 60px;
        }

        .inline-weight-slider {
            flex: 1;
            height: 4px;
            background: var(--surface-secondary);
            border-radius: 2px;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        .inline-weight-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .inline-weight-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .weight-display {
            min-width: 25px;
            text-align: center;
            font-weight: bold;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .add-item-btn {
            width: 100%;
            padding: 1rem;
            border: 2px dashed var(--border);
            border-radius: 1rem;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: inherit;
            font-size: 1.1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .add-item-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(96, 165, 250, 0.1);
        }

        /* Edit Panel Styles - Remove this section */
        .popup-window.expanded {
            max-width: 600px;
            width: 95%;
        }

        /* Sync icon styles */
        .url-input-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .url-input-container .setting-input {
            flex: 1;
        }        .sync-icon {
            width: auto;
            height: 54px;
            padding: 0 1rem;
            background: linear-gradient(145deg, var(--surface-secondary), var(--accent));
            border: 2px solid var(--border);
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .sync-icon:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px var(--shadow);
        }

        .sync-icon:active {
            transform: translateY(0);
        }

        .sync-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--text-primary);
        }

        .sync-icon.syncing svg {
            animation: spin 1s linear infinite;
        }        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Mobile compatibility styles */
        @media (max-width: 768px) {
            #display {
                font-size: 1.8rem;
                padding: 1.5rem;
                margin: 1rem;
                width: calc(100vw - 2rem);
                min-height: 150px;
            }

            .card-text {
                font-size: 1.8rem;
            }

            .card-button {
                font-size: 1rem;
                padding: 0.8rem 1.5rem;
                min-width: 100px;
            }

            .popup-window {
                width: 95%;
                padding: 1.5rem;
                margin: 1rem;
            }

            .popup-window.expanded {
                max-width: none;
                width: 95%;
            }

            .popup-title {
                font-size: 1.5rem;
            }

            .data-item {
                padding: 0.8rem;
                margin-bottom: 0.8rem;
            }

            .drag-handle {
                width: 20px;
                height: 20px;
                top: 0.3rem;
                right: 0.3rem;
            }

            .drag-handle svg {
                width: 14px;
                height: 14px;
            }

            .data-item-text {
                padding: 0.4rem;
                font-size: 0.9rem;
            }

            .data-item-url {
                font-size: 0.8rem;
                padding: 0.2rem 0.4rem;
            }

            .weight-control {
                gap: 0.8rem;
            }

            .weight-label {
                font-size: 0.8rem;
                min-width: 50px;
            }

            .menu-icon {
                width: 40px;
                height: 40px;
                top: 15px;
                right: 15px;
            }

            .menu-icon svg {
                width: 20px;
                height: 20px;
            }

            .setting-input {
                padding: 0.8rem;
                font-size: 0.9rem;
            }

            .sync-icon {
                height: 44px;
                padding: 0 0.8rem;
            }

            .sync-icon svg {
                width: 16px;
                height: 16px;
            }

            .drag-delete-hint {
                bottom: 15px;
                font-size: 0.7rem;
                padding: 0.4rem 0.8rem;
            }
        }

        @media (max-width: 480px) {
            #display {
                font-size: 1.5rem;
                padding: 1rem;
            }

            .card-text {
                font-size: 1.5rem;
            }

            .popup-window {
                padding: 1rem;
            }

            .popup-title {
                font-size: 1.3rem;
            }

            .drag-delete-hint {
                font-size: 0.6rem;
                padding: 0.3rem 0.6rem;
            }
        }
    </style>
</head>

<body>
    <!-- Menu Icon -->
    <div class="menu-icon" onclick="openSettingsPopup()">
        <svg viewBox="0 0 24 24">
            <path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" />
        </svg>
    </div>    <div id="display">
        <div class="card-text">Click to get a random option</div>
    </div>

    <!-- Delete hint at bottom of screen -->
    <div id="deleteHint" class="drag-delete-hint">🗑️ Drop here to delete</div><!-- Settings Popup -->
    <div id="settingsPopup" class="popup-overlay">
        <div class="popup-window expanded">
            <div class="settings-content">
                <div class="popup-title">Settings</div>

                <div class="data-section">
                    <div class="section-title">Data Items</div>
                    <div id="dataItemsList"></div>
                    <button class="add-item-btn" onclick="addNewItem()">+ Add New Item</button>
                </div>
                <div class="setting-row">
                    <div class="setting-label">Server URL</div>
                    <div class="url-input-container">
                        <input type="url" id="urlInput" class="setting-input" placeholder="URL to JSON file">
                        <div class="sync-icon" onclick="syncFromServer()" title="Sync from server">
                            <svg viewBox="0 0 24 24">
                                <path
                                    d="M12,18A6,6 0 0,1 6,12C6,11 6.25,10.03 6.7,9.2L5.24,7.74C4.46,8.97 4,10.43 4,12A8,8 0 0,0 12,20V23L16,19L12,15M12,4V1L8,5L12,9V6A6,6 0 0,1 18,12C18,13 17.75,13.97 17.3,14.8L18.76,16.26C19.54,15.03 20,13.57 20,12A8,8 0 0,0 12,4Z" />
                            </svg>
                        </div>
                    </div>
                </div>

                <div class="setting-row" style="margin-top: 2rem;">
                    <div class="setting-label">Password</div>
                    <input type="password" id="passwordInput" class="setting-input" placeholder="For saving data">
                </div>
                <div class="popup-buttons">
                    <button class="popup-button" onclick="closeSettings()">Close</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        let weightedOptions = [];
        let localData = []; // Store local copy for editing
        let displayElem = document.getElementById('display'); let currentUrl = '';
        let currentPassword = '';
        let isPopupOpen = false;
        let lastSelectedOption = null;
        function initializeSettings() {
            const savedUrl = localStorage.getItem('bored.url');
            const savedPassword = localStorage.getItem('bored.password');
            if (savedUrl) currentUrl = savedUrl;
            if (savedPassword) currentPassword = savedPassword;

            // Always load data (will use default.json if no URL is saved)
            loadData().catch(() => openSettingsPopup());
        }

        function updateDisplay() {
            if (!weightedOptions || weightedOptions.length === 0) {
                displayElem.innerHTML = `
                    <div class="card-text">No data available</div>
                `;
                return;
            }

            let selectedOption = null;

            // If we have 2 or more options, ensure we don't repeat the last one
            if (weightedOptions.length >= 2 && lastSelectedOption) {
                const availableOptions = weightedOptions.filter(option => option !== lastSelectedOption);

                if (availableOptions.length > 0) {
                    // Calculate total weight for available options
                    const totalWeight = availableOptions.reduce((sum, option) => sum + option.weight, 0);

                    // Generate random number between 0 and totalWeight
                    const random = Math.random() * totalWeight;

                    // Find the selected option based on weight
                    let currentWeight = 0;
                    for (const option of availableOptions) {
                        currentWeight += option.weight;
                        if (random <= currentWeight) {
                            selectedOption = option;
                            break;
                        }
                    }

                    // Fallback to last available option
                    if (!selectedOption) {
                        selectedOption = availableOptions[availableOptions.length - 1];
                    }
                }
            }

            // If we couldn't select from available options or have less than 2 options, use normal selection
            if (!selectedOption) {
                // Calculate total weight
                const totalWeight = weightedOptions.reduce((sum, option) => sum + option.weight, 0);

                // Generate random number between 0 and totalWeight
                const random = Math.random() * totalWeight;

                // Find the selected option based on weight
                let currentWeight = 0;
                for (const option of weightedOptions) {
                    currentWeight += option.weight;
                    if (random <= currentWeight) {
                        selectedOption = option;
                        break;
                    }
                }

                // Fallback to last option
                if (!selectedOption) {
                    selectedOption = weightedOptions[weightedOptions.length - 1];
                }
            }

            // Store the selected option for next time
            lastSelectedOption = selectedOption;

            // Display the selected option as a card
            displayCard(selectedOption);
        }        function displayCard(option) {
            let cardHTML = `<div class="card-text">${option.text}</div>`;

            // Check if the option has a URL
            if (option.url) {
                // Show full URL after https://
                let displayUrl = option.url;
                try {
                    const url = new URL(option.url);
                    // Remove protocol and show everything after https://
                    displayUrl = option.url.replace(/^https?:\/\//, '');
                } catch (e) {
                    // If URL parsing fails, use the original URL
                    displayUrl = option.url;
                }

                cardHTML += `<a href="${option.url}" target="_blank" class="card-button" onclick="event.stopPropagation()">${displayUrl}</a>`;
            }

            displayElem.innerHTML = cardHTML;
        }function loadData() {
            // If no URL is set, use default.json
            const dataUrl = currentUrl || 'default.json';

            // First try to load from localStorage
            const savedData = localStorage.getItem('bored.localData');
            const savedUrl = localStorage.getItem('bored.url');

            if (savedData && savedUrl === currentUrl && currentUrl) {
                try {
                    localData = JSON.parse(savedData);
                    processLocalData();
                    updateDisplay();
                    return Promise.resolve();
                } catch (e) {
                    console.warn('Failed to parse saved data, fetching from URL');
                }
            }

            return fetch(dataUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Validate that data is an array
                    if (!Array.isArray(data)) {
                        throw new Error('Data must be an array of options');
                    }

                    // Store original data
                    localData = data.map(item => ({
                        text: item.text || '',
                        weight: item.weight || 1,
                        url: item.url || ''
                    }));

                    // Save to localStorage only if we have a custom URL
                    if (currentUrl) {
                        localStorage.setItem('bored.localData', JSON.stringify(localData));
                    }

                    processLocalData();
                    updateDisplay();
                }).catch(error => {
                    console.error('Error loading data:', error);
                    displayElem.innerHTML = `
                        <div class="card-text">Error loading data</div>
                    `;
                    weightedOptions = [];
                    throw error;
                });
        }

        function processLocalData() {
            weightedOptions = [];

            for (const item of localData) {
                const weight = item.weight || 1.0;
                const text = item.text;
                const url = item.url || null;

                if (text && weight > 0) {
                    weightedOptions.push({
                        text,
                        weight,
                        url
                    });
                }
            }

            // Allow empty data - no error throwing
        }

        // Settings popup functions
        function openSettingsPopup() {
            isPopupOpen = true;
            document.getElementById('urlInput').value = currentUrl || '';
            document.getElementById('passwordInput').value = currentPassword || '';
            populateDataItemsList();
            document.getElementById('settingsPopup').style.display = 'block';
        }        function populateDataItemsList() {
            const listContainer = document.getElementById('dataItemsList');
            listContainer.innerHTML = '';

            localData.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'data-item';
                itemDiv.draggable = true;
                itemDiv.dataset.index = index;

                // Add drag handle
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M7,19V17H9V19H7M11,19V17H13V19H11M15,19V17H17V19H15M7,15V13H9V15H7M11,15V13H13V15H11M15,15V13H17V15H15M7,11V9H9V11H7M11,11V9H13V11H11M15,11V9H17V11H15M7,7V5H9V7H7M11,7V5H13V7H11M15,7V5H17V7H15Z"/>
                    </svg>
                `;

                // Drag event listeners
                itemDiv.addEventListener('dragstart', handleDragStart);
                itemDiv.addEventListener('dragover', handleDragOver);
                itemDiv.addEventListener('drop', handleDrop);
                itemDiv.addEventListener('dragend', handleDragEnd);
                itemDiv.addEventListener('dragenter', handleDragEnter);
                itemDiv.addEventListener('dragleave', handleDragLeave);

                // Text element (editable on double click)
                const textDiv = document.createElement('div');
                textDiv.className = 'data-item-text';
                textDiv.textContent = item.text || 'Empty text';
                textDiv.addEventListener('dblclick', () => editText(textDiv, index));
                // URL element (editable on double click)
                const urlDiv = document.createElement('div');
                urlDiv.className = 'data-item-url';
                urlDiv.textContent = item.url ? item.url : ' ';
                urlDiv.addEventListener('dblclick', () => editUrl(urlDiv, index));

                // Weight control
                const weightDiv = document.createElement('div');
                weightDiv.className = 'weight-control';

                const weightLabel = document.createElement('span');
                weightLabel.className = 'weight-label';
                weightLabel.textContent = 'Weight:';

                const weightSlider = document.createElement('input');
                weightSlider.type = 'range';
                weightSlider.min = '1';
                weightSlider.max = '10';
                weightSlider.value = item.weight || 1;
                weightSlider.className = 'inline-weight-slider';                const weightDisplay = document.createElement('span');
                weightDisplay.className = 'weight-display';
                weightDisplay.textContent = item.weight || 1;
                weightSlider.addEventListener('input', function () {
                    const currentIndex = parseInt(itemDiv.dataset.index);
                    weightDisplay.textContent = this.value;
                    localData[currentIndex].weight = parseInt(this.value);
                });

                weightDiv.appendChild(weightLabel);
                weightDiv.appendChild(weightSlider);
                weightDiv.appendChild(weightDisplay);

                itemDiv.appendChild(dragHandle);
                itemDiv.appendChild(textDiv);
                itemDiv.appendChild(urlDiv);
                itemDiv.appendChild(weightDiv);

                listContainer.appendChild(itemDiv);
            });
        }        function editText(textDiv, originalIndex) {
            // Find the current index in case items were reordered
            const itemDiv = textDiv.closest('.data-item');
            const currentIndex = parseInt(itemDiv.dataset.index);
            const currentText = localData[currentIndex].text || '';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.className = 'data-item-text-input';
            
            let isSaved = false;
            
            function saveText() {
                if (isSaved) return;
                isSaved = true;
                
                const newText = input.value.trim(); if (newText === '') {
                    // Delete item if text is empty
                    if (confirm('Delete this item?')) {
                        localData.splice(currentIndex, 1);
                        populateDataItemsList();
                    } else {
                        textDiv.textContent = currentText || 'Empty text';
                    }
                } else {
                    localData[currentIndex].text = newText;
                    textDiv.textContent = newText;
                }
                textDiv.style.display = 'block';
                if (input.parentNode) {
                    input.remove();
                }
            }            input.addEventListener('blur', saveText);
            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    saveText();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    saveText();
                    // Focus on the URL element for editing
                    setTimeout(() => {
                        const urlDiv = textDiv.parentNode.querySelector('.data-item-url');
                        if (urlDiv) {
                            urlDiv.dispatchEvent(new Event('dblclick'));
                        }
                    }, 100);
                }
            });

            textDiv.style.display = 'none';
            textDiv.parentNode.insertBefore(input, textDiv);
            input.focus();
            input.select();
        }        function editUrl(urlDiv, originalIndex) {
            // Find the current index in case items were reordered
            const itemDiv = urlDiv.closest('.data-item');
            const currentIndex = parseInt(itemDiv.dataset.index);
            const currentUrl = localData[currentIndex].url || '';

            const input = document.createElement('input');
            input.type = 'url';
            input.value = currentUrl;
            input.className = 'data-item-url-input';
            
            let isSaved = false;
            
            function saveUrl() {
                if (isSaved) return;
                isSaved = true;
                
                const newUrl = input.value.trim(); localData[currentIndex].url = newUrl;
                urlDiv.textContent = newUrl;
                urlDiv.style.display = 'block';
                if (input.parentNode) {
                    input.remove();
                }
            }            input.addEventListener('blur', saveUrl);
            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    saveUrl();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    saveUrl();
                }
            });

            urlDiv.style.display = 'none';
            urlDiv.parentNode.insertBefore(input, urlDiv);
            input.focus();
            input.select();
        }function closeSettingsPopup() {
            isPopupOpen = false;
            document.getElementById('settingsPopup').style.display = 'none';
        }

        function updateLocalDisplay() {
            // Just update the display without saving
            processLocalData();
            updateDisplay();
        } function syncFromServer() {
            // Get URL from input field in case it was changed but not saved yet
            const urlFromInput = document.getElementById('urlInput').value.trim();
            const urlToSync = urlFromInput || currentUrl;

            if (!urlToSync) {
                alert('Please enter a server URL first');
                return;
            }

            const syncIcon = document.querySelector('.sync-icon');
            syncIcon.classList.add('syncing');

            fetch(urlToSync)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Validate that data is an array
                    if (!Array.isArray(data)) {
                        throw new Error('Data must be an array of options');
                    }

                    // Override local data with server data
                    localData = data.map(item => ({
                        text: item.text || '',
                        weight: item.weight || 1,
                        url: item.url || ''
                    }));

                    // Update the display and repopulate the list
                    populateDataItemsList();
                    updateLocalDisplay();
                })
                .catch(error => {
                    console.error('Error syncing from server:', error);
                    alert('Failed to sync data from server: ' + error.message);
                })
                .finally(() => {
                    syncIcon.classList.remove('syncing');
                });
        } function postDataToUrl() {
            if (!currentUrl || !currentPassword) {
                return Promise.resolve();
            }

            // Extract the key from the URL (last segment)
            const url = new URL(currentUrl);
            const pathSegments = url.pathname.split('/').filter(segment => segment);
            const key = pathSegments[pathSegments.length - 1].replace('.json', '');

            // Build the parent URL
            const parentPath = pathSegments.slice(0, -1).join('/');
            const postUrl = url.origin + (parentPath ? '/' + parentPath : '');

            const payload = {
                key: key,
                value: localData,
                pswd: currentPassword
            };            return fetch(postUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            }).then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Check if response has content
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    return response.json();
                } else {
                    // If response is just "Ok" or plain text, return a simple success object
                    return response.text().then(text => {
                        if (text.toLowerCase().includes('ok') || text.trim() === '') {
                            return { success: true, message: text };
                        } else {
                            throw new Error(`Unexpected response: ${text}`);
                        }
                    });
                }
            });
        } function closeSettings() {
            const newUrl = document.getElementById('urlInput').value.trim();
            const newPassword = document.getElementById('passwordInput').value.trim();

            // Update local display
            updateLocalDisplay();

            // Save password
            currentPassword = newPassword;
            localStorage.setItem('bored.password', currentPassword);

            // Update URL if changed
            if (newUrl !== currentUrl) {
                currentUrl = newUrl;
                localStorage.setItem('bored.url', currentUrl);
            }

            // Save local data to localStorage if we have a URL
            if (currentUrl) {
                localStorage.setItem('bored.localData', JSON.stringify(localData));
            }

            // Close popup first
            closeSettingsPopup();

            // Push to server if URL and password are provided
            if (currentUrl && currentPassword) {
                postDataToUrl().then(() => {
                    console.log('Data saved to server successfully');
                }).catch(error => {
                    console.error('Error saving to server:', error);
                    alert('Failed to save data to server: ' + error.message);
                });
            }
        } function addNewItem() {
            const newItem = {
                text: 'New item',
                url: '',
                weight: 1
            };
            localData.push(newItem);
            populateDataItemsList();

            // Focus on the text input of the newly added item
            setTimeout(() => {
                const dataItems = document.querySelectorAll('.data-item-text');
                if (dataItems.length > 0) {
                    const lastItem = dataItems[dataItems.length - 1];
                    lastItem.dispatchEvent(new Event('dblclick'));
                }
            }, 100);
        }        // Drag and drop functionality
        let draggedElement = null;
        let draggedIndex = null;
        let isOverDataList = false;        function handleDragStart(e) {
            draggedElement = this;
            draggedIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
            
            // Add document-level drag tracking for better detection
            document.addEventListener('dragover', handleDocumentDragOver);
            
            isOverDataList = true; // Start as true since drag starts inside the list
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            if (this !== draggedElement) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            if (this !== draggedElement) {
                const targetIndex = parseInt(this.dataset.index);
                
                // Move the item in the localData array
                const draggedItem = localData[draggedIndex];
                localData.splice(draggedIndex, 1);
                localData.splice(targetIndex, 0, draggedItem);
                
                // Refresh the list
                populateDataItemsList();
            }
            
            return false;
        }        function handleDragEnd(e) {
            this.classList.remove('dragging');
            
            // Clean up all drag-over classes
            const allItems = document.querySelectorAll('.data-item');
            allItems.forEach(item => {
                item.classList.remove('drag-over');
            });
            
            // Remove the event listeners
            document.removeEventListener('dragover', handleDocumentDragOver);
            
            // Hide delete hint
            const deleteHint = document.getElementById('deleteHint');
            deleteHint.classList.remove('show');
            
            // Check if the item was dragged outside the data list
            if (!isOverDataList && draggedElement && draggedIndex !== null) {
                const itemText = localData[draggedIndex].text || 'this item';
                if (confirm(`Delete "${itemText}"?`)) {
                    localData.splice(draggedIndex, 1);
                    populateDataItemsList();
                }
            }
            
            draggedElement = null;
            draggedIndex = null;
            isOverDataList = false;
        }function handleDocumentDragOver(e) {
            e.preventDefault();
            
            // Check if we're over the data items list
            const dataItemsList = document.getElementById('dataItemsList');
            const rect = dataItemsList.getBoundingClientRect();
            const x = e.clientX;
            const y = e.clientY;
            
            const previousState = isOverDataList;
            isOverDataList = (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom);
              // Only update delete hint when state changes
            if (previousState !== isOverDataList) {
                const deleteHint = document.getElementById('deleteHint');
                if (isOverDataList) {
                    deleteHint.classList.remove('show');
                } else {
                    deleteHint.classList.add('show');
                }
            }}

        // Event listeners
        let hasTouchSupport = 'ontouchstart' in window;
        
        // Add touch support for mobile drag and drop
        if (hasTouchSupport) {
            document.addEventListener('touchstart', (e) => {
                if (!isPopupOpen) {
                    updateDisplay();
                }
            });
            
            // Mobile drag detection using touch events
            let touchStartY = 0;
            let touchStartElement = null;
            
            document.addEventListener('touchstart', (e) => {
                const target = e.target.closest('.data-item');
                if (target && target.draggable) {
                    touchStartY = e.touches[0].clientY;
                    touchStartElement = target;
                }
            });
            
            document.addEventListener('touchmove', (e) => {
                if (touchStartElement) {
                    e.preventDefault(); // Prevent scrolling while dragging
                    const currentY = e.touches[0].clientY;
                    const deltaY = Math.abs(currentY - touchStartY);
                    
                    // Start drag simulation if moved enough
                    if (deltaY > 10 && !touchStartElement.classList.contains('dragging')) {
                        // Simulate drag start
                        draggedElement = touchStartElement;
                        draggedIndex = parseInt(touchStartElement.dataset.index);
                        touchStartElement.classList.add('dragging');
                        
                        // Add document drag listener
                        document.addEventListener('touchmove', handleTouchDragOver);
                        isOverDataList = true;
                    }
                }
            });
            
            document.addEventListener('touchend', (e) => {
                if (touchStartElement && touchStartElement.classList.contains('dragging')) {
                    // Simulate drag end
                    touchStartElement.classList.remove('dragging');
                    
                    // Clean up
                    const allItems = document.querySelectorAll('.data-item');
                    allItems.forEach(item => item.classList.remove('drag-over'));
                    
                    document.removeEventListener('touchmove', handleTouchDragOver);
                    
                    // Hide delete hint
                    const deleteHint = document.getElementById('deleteHint');
                    deleteHint.classList.remove('show');
                    
                    // Check for deletion
                    if (!isOverDataList && draggedElement && draggedIndex !== null) {
                        const itemText = localData[draggedIndex].text || 'this item';
                        if (confirm(`Delete "${itemText}"?`)) {
                            localData.splice(draggedIndex, 1);
                            populateDataItemsList();
                        }
                    }
                    
                    // Reset
                    draggedElement = null;
                    draggedIndex = null;
                    isOverDataList = false;
                }
                touchStartElement = null;
                touchStartY = 0;
            });
            
            function handleTouchDragOver(e) {
                if (!draggedElement) return;
                
                const touch = e.touches[0];
                const dataItemsList = document.getElementById('dataItemsList');
                const rect = dataItemsList.getBoundingClientRect();
                
                const previousState = isOverDataList;
                isOverDataList = (touch.clientX >= rect.left && touch.clientX <= rect.right && 
                                touch.clientY >= rect.top && touch.clientY <= rect.bottom);
                
                if (previousState !== isOverDataList) {
                    const deleteHint = document.getElementById('deleteHint');
                    if (isOverDataList) {
                        deleteHint.classList.remove('show');
                    } else {
                        deleteHint.classList.add('show');
                    }
                }
            }
        } else {
            document.addEventListener('click', (e) => {
                if (!isPopupOpen) {
                    updateDisplay();
                }
            });
        }

        // Initialize on page load
        initializeSettings();
    </script>
</body>

</html>